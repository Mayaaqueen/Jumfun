1. We will be adding the clanker-sdk to this miniapp and create the ability to deploy a clanker token
2. clanker-sdk takes information, and calculates things and then passes them on like here: from clanker-sdk github: import {
  type Address,
  type PublicClient,
  type WalletClient,
  parseEther,
  parseUnits,
  stringify,
  parseEventLogs,
} from 'viem';
import { simulateContract, writeContract, readContract } from 'viem/actions';
import type {
  ClankerConfig,
  DeploymentConfig,
  SimpleTokenConfig,
  RewardsConfig,
  InitialBuyConfig,
} from './types';
import { CLANKER_FACTORY_V3_1, WETH_ADDRESS } from './constants';
import { Clanker_v3_1_abi } from './abis/Clanker_V3_1';

// ERC20 decimals ABI
const ERC20_DECIMALS_ABI = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ type: "uint8", name: "" }],
    stateMutability: "view",
    type: "function"
  }
] as const;

// Uniswap V3 Factory ABI for getting pools
const UNIV3_FACTORY_ABI = [
  {
    inputs: [
      { internalType: 'address', name: 'tokenA', type: 'address' },
      { internalType: 'address', name: 'tokenB', type: 'address' },
      { internalType: 'uint24', name: 'fee', type: 'uint24' }
    ],
    name: 'getPool',
    outputs: [{ internalType: 'address', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function'
  }
] as const;

// Uniswap V3 Pool ABI for getting liquidity
const UNIV3_POOL_ABI = [
  {
    inputs: [],
    name: 'liquidity',
    outputs: [{ internalType: 'uint128', name: '', type: 'uint128' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'slot0',
    outputs: [
      { internalType: 'uint160', name: 'sqrtPriceX96', type: 'uint160' },
      { internalType: 'int24', name: 'tick', type: 'int24' },
      { internalType: 'uint16', name: 'observationIndex', type: 'uint16' },
      { internalType: 'uint16', name: 'observationCardinality', type: 'uint16' },
      { internalType: 'uint16', name: 'observationCardinalityNext', type: 'uint16' },
      { internalType: 'uint8', name: 'feeProtocol', type: 'uint8' },
      { internalType: 'bool', name: 'unlocked', type: 'bool' }
    ],
    stateMutability: 'view',
    type: 'function'
  }
] as const;

// Base Uniswap V3 Factory address
const UNIV3_FACTORY = '0x33128a8fC17869897dcE68Ed026d694621f6FDfD' as const;

// Available fee tiers
const FEE_TIERS = [100, 500, 3000, 10000] as const;

export class Clanker {
  private readonly wallet: WalletClient;
  private readonly factoryAddress: Address;
  private readonly publicClient: PublicClient;

  constructor(config: ClankerConfig) {
    this.wallet = config.wallet;
    this.publicClient = config.publicClient;
    this.factoryAddress = config.factoryAddress ?? CLANKER_FACTORY_V3_1;
  }

  // Get quote token decimals
  private async getQuoteTokenDecimals(quoteToken: Address): Promise<number> {
    try {
      const decimals = await readContract(this.publicClient, {
        address: quoteToken,
        abi: ERC20_DECIMALS_ABI,
        functionName: 'decimals',
      });
      return decimals;
    } catch (error) {
      console.warn(`Failed to fetch decimals for quote token ${quoteToken}, defaulting to 18:`, error);
      return 18;
    }
  }

  // Find the most liquid pool between WETH and quote token
  private async findMostLiquidPool(quoteToken: Address): Promise<{ fee: number; sqrtPriceX96: bigint }> {
    const pools = await Promise.all(
      FEE_TIERS.map(async (fee) => {
        try {
          // Get pool address
          const poolAddress = await readContract(this.publicClient, {
            address: UNIV3_FACTORY,
            abi: UNIV3_FACTORY_ABI,
            functionName: 'getPool',
            args: [WETH_ADDRESS, quoteToken, fee],
          });

          if (poolAddress === '0x0000000000000000000000000000000000000000') {
            return { fee, liquidity: 0n, sqrtPriceX96: 0n };
          }

          // Get pool liquidity and price
          const [liquidity, slot0] = await Promise.all([
            readContract(this.publicClient, {
              address: poolAddress,
              abi: UNIV3_POOL_ABI,
              functionName: 'liquidity',
            }),
            readContract(this.publicClient, {
              address: poolAddress,
              abi: UNIV3_POOL_ABI,
              functionName: 'slot0',
            }),
          ]);

          return { fee, liquidity, sqrtPriceX96: slot0[0] };
        } catch (error) {
          console.warn(`Failed to get pool info for fee tier ${fee}:`, error);
          return { fee, liquidity: 0n, sqrtPriceX96: 0n };
        }
      })
    );

    // Find pool with highest liquidity
    const mostLiquidPool = pools.reduce((max, current) => 
      current.liquidity > max.liquidity ? current : max
    );

    if (mostLiquidPool.liquidity === 0n) {
      // If no liquid pool found, default to 1% fee tier
      console.warn('No liquid pool found, defaulting to 1% fee tier');
      return { fee: 10000, sqrtPriceX96: 0n };
    }

    return { fee: mostLiquidPool.fee, sqrtPriceX96: mostLiquidPool.sqrtPriceX96 };
  }

  // Calculate minimum output amount for WETH -> quote token swap
  private calculateMinimumOutput(
    ethAmount: bigint,
    sqrtPriceX96: bigint,
    quoteDecimals: number,
    slippagePercent: number
  ): bigint {
    if (sqrtPriceX96 === 0n) {
      // If we couldn't get the price, return 0 (no minimum)
      return 0n;
    }

    // Calculate price from sqrtPriceX96
    const Q96 = BigInt('79228162514264337593543950336'); // 2^96
    const price = (Number(sqrtPriceX96) / Number(Q96)) ** 2;

    // Calculate expected output in quote token
    const ethDecimals = 18;
    const ethAmountInEth = Number(ethAmount) / 10 ** ethDecimals;
    const expectedOutput = ethAmountInEth * price;

    // Apply slippage tolerance
    const minimumOutput = expectedOutput * (1 - slippagePercent / 100);

    // Convert to quote token base units
    return BigInt(Math.floor(minimumOutput * 10 ** quoteDecimals));
  }

  // Calculate tick based on quote token and token ordering
  private async calculateTickForQuoteToken(quoteToken: Address, marketCap: bigint): Promise<number> {
    // Get quote token decimals
    const quoteDecimals = await this.getQuoteTokenDecimals(quoteToken);
    console.log('Quote token decimals:', quoteDecimals);

    // Our token always has 18 decimals and total supply is 100B
    const tokenDecimals = 18;
    const totalSupply = BigInt(100_000_000_000) * BigInt(10) ** BigInt(tokenDecimals);
    
    // Calculate price in quote token per token
    // If we want market cap of 100 USDC to show as 100 USDC on Dexscreener:
    // price = marketCap / totalSupply
    // Note: marketCap is already in quote token base units (e.g. 100 * 10^6 for USDC)
    const priceInQuoteToken = Number(marketCap) / Number(totalSupply);
    console.log('Price in quote token:', priceInQuoteToken);
    console.log('Market cap in quote token units:', Number(marketCap) / 10 ** quoteDecimals);

    // Calculate tick using the 1.0001 base formula
    // tick = log_1.0001(price)
    const logBase = 1.0001;
    const tickSpacing = 200; // Fixed for 1% fee tier

    // In Uniswap V3, token0 is the token with the lower address
    // If our new token's address will be higher than the quote token,
    // we need to invert the price for the tick calculation
    const dummyTokenAddress = '0xffffffffffffffffffffffffffffffffffffffff'; // Max possible address
    const isToken0 = dummyTokenAddress.toLowerCase() < quoteToken.toLowerCase();
    console.log('Is new token token0?', isToken0);

    // Calculate raw tick using log base formula
    // If we're not token0, we need to invert the price and negate the tick
    const priceForTick = isToken0 ? priceInQuoteToken : 1 / priceInQuoteToken;
    let rawTick = Math.floor(Math.log(priceForTick) / Math.log(logBase));
    if (!isToken0) {
      rawTick = -rawTick; // Negate the tick for token1
    }
    console.log('Raw tick (before spacing):', rawTick);

    // Round to valid tick spacing
    const initialTick = Math.floor(rawTick / tickSpacing) * tickSpacing;
    console.log('Final tick (rounded to spacing):', initialTick);

    // Verify the price calculation
    const actualPrice = Math.pow(logBase, isToken0 ? initialTick : -initialTick);
    console.log('Actual price from tick:', actualPrice);
    
    // Calculate actual market cap in quote token units
    // If we're not token0, we need to invert the actual price
    const finalPrice = isToken0 ? actualPrice : 1 / actualPrice;
    const actualMarketCap = finalPrice * Number(totalSupply) / Math.pow(10, tokenDecimals);
    console.log('Actual market cap in quote token:', actualMarketCap);

    return initialTick;
  }

  private handleError(error: unknown): never {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Deployment failed: ${message}`);
  }

  public async deploy(config: DeploymentConfig): Promise<Address> {
    if (!this.wallet.account) {
      throw new Error('Wallet account not configured');
    }

    try {
      // Since RewardsConfig is required in DeploymentConfig, we can safely access it
      const rewardsConfig: RewardsConfig = config.rewardsConfig;

      // Calculate tick based on quote token and market cap
      const tick = await this.calculateTickForQuoteToken(
        config.poolConfig.pairedToken,
        config.poolConfig.initialMarketCapInPairedToken
      );

      // Create deployment data array
      const deploymentData = {
        tokenConfig: {
          name: config.tokenConfig.name,
          symbol: config.tokenConfig.symbol,
          salt: config.tokenConfig.salt,
          image: config.tokenConfig.image,
          metadata: stringify(config.tokenConfig.metadata),
          context: stringify(config.tokenConfig.context),
          originatingChainId: config.tokenConfig.originatingChainId,
        },
        vaultConfig: {
          vaultPercentage: config.vaultConfig?.vaultPercentage ?? 0,
          vaultDuration: config.vaultConfig?.vaultDuration ?? BigInt(0),
        },
        poolConfig: {
          pairedToken: config.poolConfig.pairedToken,
          tickIfToken0IsNewToken: tick,
        },
        initialBuyConfig: {
          pairedTokenPoolFee:
            config.initialBuyConfig?.pairedTokenPoolFee ?? 10000,
          pairedTokenSwapAmountOutMinimum:
            config.initialBuyConfig?.pairedTokenSwapAmountOutMinimum ?? BigInt(0),
        },
        rewardsConfig: {
          creatorReward: rewardsConfig.creatorReward,
          creatorAdmin: rewardsConfig.creatorAdmin,
          creatorRewardRecipient: rewardsConfig.creatorRewardRecipient,
          interfaceAdmin: rewardsConfig.interfaceAdmin,
          interfaceRewardRecipient: rewardsConfig.interfaceRewardRecipient,
        },
      } as const;

      const { request } = await simulateContract(this.publicClient, {
        address: this.factoryAddress,
        abi: Clanker_v3_1_abi,
        functionName: 'deployToken',
        args: [deploymentData],
        value: config.initialBuyConfig?.ethAmount ?? BigInt(0),
        chain: this.publicClient.chain,
        account: this.wallet.account,
      });

      // Deploy token
      const hash = await writeContract(this.wallet, request);

      // Wait for transaction receipt
      const receipt = await this.publicClient.waitForTransactionReceipt({
        hash,
      });

      const [log] = parseEventLogs({
        abi: Clanker_v3_1_abi,
        eventName: 'TokenCreated',
        logs: receipt.logs,
      });

      if (!log) {
        throw new Error('No deployment event found');
      }

      return log.args.tokenAddress;
    } catch (error) {
      this.handleError(error);
    }
  }

  /**
   * Simplified token deployment method for easier user experience
   * @param config Simple configuration for token deployment
   * @returns Deployed token address
   */
  public async deployToken(config: SimpleTokenConfig): Promise<Address> {
    if (!this.wallet.account) {
      throw new Error('Wallet account not configured');
    }

    // Store the address to avoid undefined checks
    const deployerAddress = this.wallet.account.address;

    // Get quote token decimals for proper unit parsing
    const quoteToken = config.pool?.quoteToken ?? WETH_ADDRESS;
    const quoteDecimals = await this.getQuoteTokenDecimals(quoteToken);
    console.log('Quote token decimals:', quoteDecimals);

    // If dev buy is enabled, find the most liquid pool and calculate minimum output
    let initialBuyConfig: InitialBuyConfig = {
      pairedTokenPoolFee: 10000, // Default to 1%
      pairedTokenSwapAmountOutMinimum: BigInt(0),
      ethAmount: undefined,
    };
    
    if (config.devBuy) {
      const ethAmount = parseEther(config.devBuy.ethAmount);
      const { fee, sqrtPriceX96 } = await this.findMostLiquidPool(quoteToken);
      const minOutput = this.calculateMinimumOutput(
        ethAmount,
        sqrtPriceX96,
        quoteDecimals,
        config.devBuy.maxSlippage ?? 5
      );
      
      initialBuyConfig = {
        pairedTokenPoolFee: fee,
        pairedTokenSwapAmountOutMinimum: minOutput,
        ethAmount,
      };

      console.log('Dev buy configuration:', {
        ethAmount: config.devBuy.ethAmount,
        fee,
        minOutput: minOutput.toString(),
      });
    }

    // Convert to internal config format
    const deploymentConfig: DeploymentConfig = {
      tokenConfig: {
        name: config.name,
        symbol: config.symbol,
        salt:
          config.salt ||
          '0x0000000000000000000000000000000000000000000000000000000000000000',
        image:
          config.image ||
          'https://ipfs.io/ipfs/QmcjfTeK3tpK3MVCQuvEaXvSscrqbL3MwsEo8LdBTWabY4',
        metadata: config.metadata || {
          description: 'Clanker Token',
          socialMediaUrls: [],
          auditUrls: [],
        },
        context: config.context || {
          interface: 'Clanker SDK',
          platform: 'Clanker',
          messageId: 'Clanker SDK',
          id: 'Clanker SDK',
        },
        originatingChainId: BigInt(this.publicClient.chain!.id),
      },
      poolConfig: {
        pairedToken: quoteToken,
        initialMarketCapInPairedToken: parseUnits(
          config.pool?.initialMarketCap ?? '100',
          quoteDecimals
        ),
      },
      vaultConfig: config.vault
        ? {
            vaultPercentage: config.vault.percentage,
            vaultDuration: BigInt(config.vault.durationInDays * 24 * 60 * 60),
          }
        : undefined,
      initialBuyConfig,
      rewardsConfig: {
        creatorReward: BigInt(40), // Default to 40% creator reward
        creatorAdmin: deployerAddress,
        creatorRewardRecipient: deployerAddress,
        interfaceAdmin: deployerAddress,
        interfaceRewardRecipient: deployerAddress,
      },
    };

    // Use existing deploy method
    return this.deploy(deploymentConfig);
  }
}

export * from './types'; -- import type { Address, PublicClient, WalletClient } from "viem";

export interface TokenConfig {
  name: string;
  symbol: string;
  salt: `0x${string}`; // bytes32
  image: string;
  metadata: IClankerMetadata;
  context: IClankerSocialContext;
  originatingChainId: bigint;
}

export interface VaultConfig {
  vaultPercentage: number; // uint8
  vaultDuration: bigint; // uint256
}

export interface PoolConfig {
  pairedToken: Address;
  initialMarketCapInPairedToken: bigint;
  initialMarketCap?: string;
  tickIfToken0IsNewToken?: number;
}

export interface InitialBuyConfig {
  pairedTokenPoolFee: number;
  pairedTokenSwapAmountOutMinimum: bigint;
  ethAmount?: bigint; // Amount of ETH to send with deployment
}

export interface RewardsConfig {
  creatorReward: bigint;
  creatorAdmin: Address;
  creatorRewardRecipient: Address;
  interfaceAdmin: Address;
  interfaceRewardRecipient: Address;
}

export interface DeploymentConfig {
  tokenConfig: TokenConfig;
  vaultConfig?: VaultConfig; // Optional
  poolConfig: PoolConfig;
  initialBuyConfig?: InitialBuyConfig; // Optional
  rewardsConfig: RewardsConfig;
}

export interface ClankerConfig {
  wallet: WalletClient;
  publicClient: PublicClient;
  factoryAddress?: Address;
}

// Simplified user-facing interface
export interface SimpleTokenConfig {
  name: string;
  symbol: string;
  salt?: `0x${string}`;
  image?: string;
  metadata?: IClankerMetadata;
  context?: IClankerSocialContext;
  pool?: {
    quoteToken?: Address;
    initialMarketCap?: string;
  };
  vault?: {
    percentage: number;
    durationInDays: number;
  };
  devBuy?: {
    ethAmount: string; // Amount of ETH to send with deployment
    maxSlippage?: number; // Max slippage percentage, defaults to 5%
  };
}

export interface IClankerMetadata {
  description?: string;
  socialMediaUrls?: { platform: string; url: string }[];
  auditUrls?: string[];
}

export interface IClankerSocialContext {
  interface: string;
  platform?: string;
  messageId?: string;
  id?: string;
} -- // Default RPC URL for Base mainnet
export const DEFAULT_BASE_RPC = "https://mainnet.base.org";

// Common addresses
export const WETH_ADDRESS = "0x4200000000000000000000000000000000000006" as const;
export const CLANKER_FACTORY_V3_1 = "0x2A787b2362021cC3eEa3C24C4748a6cD5B687382" as const;

// Minimal ERC20 ABI for fetching decimals
export const ERC20_DECIMALS_ABI = [
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "type": "uint8", "name": "" }],
    "stateMutability": "view",
    "type": "function"
  }
] as const; -- export const Clanker_v3_1_abi = [
  {
    inputs: [{ internalType: 'address', name: 'owner_', type: 'address' }],
    stateMutability: 'nonpayable',
    type: 'constructor',
  },
  { inputs: [], name: 'Deprecated', type: 'error' },
  { inputs: [], name: 'InvalidCreatorInfo', type: 'error' },
  { inputs: [], name: 'InvalidCreatorReward', type: 'error' },
  { inputs: [], name: 'InvalidInterfaceInfo', type: 'error' },
  { inputs: [], name: 'InvalidTick', type: 'error' },
  { inputs: [], name: 'InvalidVaultConfiguration', type: 'error' },
  { inputs: [], name: 'NotFound', type: 'error' },
  { inputs: [], name: 'OnlyNonOriginatingChains', type: 'error' },
  { inputs: [], name: 'OnlyOriginatingChain', type: 'error' },
  {
    inputs: [{ internalType: 'address', name: 'owner', type: 'address' }],
    name: 'OwnableInvalidOwner',
    type: 'error',
  },
  {
    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],
    name: 'OwnableUnauthorizedAccount',
    type: 'error',
  },
  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },
  { inputs: [], name: 'Unauthorized', type: 'error' },
  { inputs: [], name: 'ZeroTeamRewardRecipient', type: 'error' },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: 'address', name: 'oldClankerDeployer', type: 'address' },
      { indexed: false, internalType: 'address', name: 'newClankerDeployer', type: 'address' },
    ],
    name: 'ClankerDeployerUpdated',
    type: 'event',
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: 'address', name: 'oldLocker', type: 'address' },
      { indexed: false, internalType: 'address', name: 'newLocker', type: 'address' },
    ],
    name: 'LiquidityLockerUpdated',
    type: 'event',
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: 'address', name: 'previousOwner', type: 'address' },
      { indexed: true, internalType: 'address', name: 'newOwner', type: 'address' },
    ],
    name: 'OwnershipTransferred',
    type: 'event',
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: 'address', name: 'admin', type: 'address' },
      { indexed: false, internalType: 'bool', name: 'isAdmin', type: 'bool' },
    ],
    name: 'SetAdmin',
    type: 'event',
  },
  {
    anonymous: false,
    inputs: [{ indexed: false, internalType: 'bool', name: 'deprecated', type: 'bool' }],
    name: 'SetDeprecated',
    type: 'event',
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: 'address', name: 'tokenAddress', type: 'address' },
      { indexed: true, internalType: 'address', name: 'creatorAdmin', type: 'address' },
      { indexed: true, internalType: 'address', name: 'interfaceAdmin', type: 'address' },
      { indexed: false, internalType: 'address', name: 'creatorRewardRecipient', type: 'address' },
      {
        indexed: false,
        internalType: 'address',
        name: 'interfaceRewardRecipient',
        type: 'address',
      },
      { indexed: false, internalType: 'uint256', name: 'positionId', type: 'uint256' },
      { indexed: false, internalType: 'string', name: 'name', type: 'string' },
      { indexed: false, internalType: 'string', name: 'symbol', type: 'string' },
      {
        indexed: false,
        internalType: 'int24',
        name: 'startingTickIfToken0IsNewToken',
        type: 'int24',
      },
      { indexed: false, internalType: 'string', name: 'metadata', type: 'string' },
      { indexed: false, internalType: 'uint256', name: 'amountTokensBought', type: 'uint256' },
      { indexed: false, internalType: 'uint256', name: 'vaultDuration', type: 'uint256' },
      { indexed: false, internalType: 'uint8', name: 'vaultPercentage', type: 'uint8' },
      { indexed: false, internalType: 'address', name: 'msgSender', type: 'address' },
    ],
    name: 'TokenCreated',
    type: 'event',
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: 'address', name: 'oldVault', type: 'address' },
      { indexed: false, internalType: 'address', name: 'newVault', type: 'address' },
    ],
    name: 'VaultUpdated',
    type: 'event',
  },
  {
    inputs: [],
    name: 'MAX_CREATOR_REWARD',
    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'MAX_TICK',
    outputs: [{ internalType: 'int24', name: '', type: 'int24' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'MAX_VAULT_PERCENTAGE',
    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'POOL_FEE',
    outputs: [{ internalType: 'uint24', name: '', type: 'uint24' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'TICK_SPACING',
    outputs: [{ internalType: 'int24', name: '', type: 'int24' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'TOKEN_SUPPLY',
    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'address', name: '', type: 'address' }],
    name: 'admins',
    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'address', name: 'token', type: 'address' }],
    name: 'claimRewards',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { internalType: 'string', name: 'name', type: 'string' },
              { internalType: 'string', name: 'symbol', type: 'string' },
              { internalType: 'bytes32', name: 'salt', type: 'bytes32' },
              { internalType: 'string', name: 'image', type: 'string' },
              { internalType: 'string', name: 'metadata', type: 'string' },
              { internalType: 'string', name: 'context', type: 'string' },
              { internalType: 'uint256', name: 'originatingChainId', type: 'uint256' },
            ],
            internalType: 'struct IClanker.TokenConfig',
            name: 'tokenConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'uint8', name: 'vaultPercentage', type: 'uint8' },
              { internalType: 'uint256', name: 'vaultDuration', type: 'uint256' },
            ],
            internalType: 'struct IClanker.VaultConfig',
            name: 'vaultConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'address', name: 'pairedToken', type: 'address' },
              { internalType: 'int24', name: 'tickIfToken0IsNewToken', type: 'int24' },
            ],
            internalType: 'struct IClanker.PoolConfig',
            name: 'poolConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'uint24', name: 'pairedTokenPoolFee', type: 'uint24' },
              { internalType: 'uint256', name: 'pairedTokenSwapAmountOutMinimum', type: 'uint256' },
            ],
            internalType: 'struct IClanker.InitialBuyConfig',
            name: 'initialBuyConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'uint256', name: 'creatorReward', type: 'uint256' },
              { internalType: 'address', name: 'creatorAdmin', type: 'address' },
              { internalType: 'address', name: 'creatorRewardRecipient', type: 'address' },
              { internalType: 'address', name: 'interfaceAdmin', type: 'address' },
              { internalType: 'address', name: 'interfaceRewardRecipient', type: 'address' },
            ],
            internalType: 'struct IClanker.RewardsConfig',
            name: 'rewardsConfig',
            type: 'tuple',
          },
        ],
        internalType: 'struct IClanker.DeploymentConfig',
        name: 'deploymentConfig',
        type: 'tuple',
      },
    ],
    name: 'deployToken',
    outputs: [
      { internalType: 'address', name: 'tokenAddress', type: 'address' },
      { internalType: 'uint256', name: 'positionId', type: 'uint256' },
    ],
    stateMutability: 'payable',
    type: 'function',
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { internalType: 'string', name: 'name', type: 'string' },
              { internalType: 'string', name: 'symbol', type: 'string' },
              { internalType: 'bytes32', name: 'salt', type: 'bytes32' },
              { internalType: 'string', name: 'image', type: 'string' },
              { internalType: 'string', name: 'metadata', type: 'string' },
              { internalType: 'string', name: 'context', type: 'string' },
              { internalType: 'uint256', name: 'originatingChainId', type: 'uint256' },
            ],
            internalType: 'struct IClanker.TokenConfig',
            name: 'tokenConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'uint8', name: 'vaultPercentage', type: 'uint8' },
              { internalType: 'uint256', name: 'vaultDuration', type: 'uint256' },
            ],
            internalType: 'struct IClanker.VaultConfig',
            name: 'vaultConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'address', name: 'pairedToken', type: 'address' },
              { internalType: 'int24', name: 'tickIfToken0IsNewToken', type: 'int24' },
            ],
            internalType: 'struct IClanker.PoolConfig',
            name: 'poolConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'uint24', name: 'pairedTokenPoolFee', type: 'uint24' },
              { internalType: 'uint256', name: 'pairedTokenSwapAmountOutMinimum', type: 'uint256' },
            ],
            internalType: 'struct IClanker.InitialBuyConfig',
            name: 'initialBuyConfig',
            type: 'tuple',
          },
          {
            components: [
              { internalType: 'uint256', name: 'creatorReward', type: 'uint256' },
              { internalType: 'address', name: 'creatorAdmin', type: 'address' },
              { internalType: 'address', name: 'creatorRewardRecipient', type: 'address' },
              { internalType: 'address', name: 'interfaceAdmin', type: 'address' },
              { internalType: 'address', name: 'interfaceRewardRecipient', type: 'address' },
            ],
            internalType: 'struct IClanker.RewardsConfig',
            name: 'rewardsConfig',
            type: 'tuple',
          },
        ],
        internalType: 'struct IClanker.DeploymentConfig',
        name: 'deploymentConfig',
        type: 'tuple',
      },
      { internalType: 'address', name: 'teamRewardRecipient', type: 'address' },
    ],
    name: 'deployTokenWithCustomTeamRewardRecipient',
    outputs: [
      { internalType: 'address', name: 'tokenAddress', type: 'address' },
      { internalType: 'uint256', name: 'positionId', type: 'uint256' },
    ],
    stateMutability: 'payable',
    type: 'function',
  },
  {
    inputs: [
      {
        components: [
          { internalType: 'string', name: 'name', type: 'string' },
          { internalType: 'string', name: 'symbol', type: 'string' },
          { internalType: 'bytes32', name: 'salt', type: 'bytes32' },
          { internalType: 'string', name: 'image', type: 'string' },
          { internalType: 'string', name: 'metadata', type: 'string' },
          { internalType: 'string', name: 'context', type: 'string' },
          { internalType: 'uint256', name: 'originatingChainId', type: 'uint256' },
        ],
        internalType: 'struct IClanker.TokenConfig',
        name: 'tokenConfig',
        type: 'tuple',
      },
      { internalType: 'address', name: 'tokenAdmin', type: 'address' },
    ],
    name: 'deployTokenZeroSupply',
    outputs: [{ internalType: 'address', name: 'tokenAddress', type: 'address' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'address', name: '', type: 'address' }],
    name: 'deploymentInfoForToken',
    outputs: [
      { internalType: 'address', name: 'token', type: 'address' },
      { internalType: 'uint256', name: 'positionId', type: 'uint256' },
      { internalType: 'address', name: 'locker', type: 'address' },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'deprecated',
    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'address', name: 'user', type: 'address' }],
    name: 'getTokensDeployedByUser',
    outputs: [
      {
        components: [
          { internalType: 'address', name: 'token', type: 'address' },
          { internalType: 'uint256', name: 'positionId', type: 'uint256' },
          { internalType: 'address', name: 'locker', type: 'address' },
        ],
        internalType: 'struct IClanker.DeploymentInfo[]',
        name: '',
        type: 'tuple[]',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [
      { internalType: 'address', name: 'uniswapV3Factory_', type: 'address' },
      { internalType: 'address', name: 'positionManager_', type: 'address' },
      { internalType: 'address', name: 'swapRouter_', type: 'address' },
      { internalType: 'address', name: 'weth_', type: 'address' },
      { internalType: 'address', name: 'liquidityLocker_', type: 'address' },
      { internalType: 'address', name: 'vault_', type: 'address' },
    ],
    name: 'initialize',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [],
    name: 'liquidityLocker',
    outputs: [{ internalType: 'contract ILpLockerv2', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'owner',
    outputs: [{ internalType: 'address', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'positionManager',
    outputs: [{ internalType: 'contract INonfungiblePositionManager', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'renounceOwnership',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [
      { internalType: 'address', name: 'admin', type: 'address' },
      { internalType: 'bool', name: 'isAdmin', type: 'bool' },
    ],
    name: 'setAdmin',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'bool', name: 'deprecated_', type: 'bool' }],
    name: 'setDeprecated',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [],
    name: 'swapRouter',
    outputs: [{ internalType: 'contract ISwapRouter', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [
      { internalType: 'address', name: '', type: 'address' },
      { internalType: 'uint256', name: '', type: 'uint256' },
    ],
    name: 'tokensDeployedByUsers',
    outputs: [
      { internalType: 'address', name: 'token', type: 'address' },
      { internalType: 'uint256', name: 'positionId', type: 'uint256' },
      { internalType: 'address', name: 'locker', type: 'address' },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'address', name: 'newOwner', type: 'address' }],
    name: 'transferOwnership',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [],
    name: 'uniswapV3Factory',
    outputs: [{ internalType: 'contract IUniswapV3Factory', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'address', name: 'newLocker', type: 'address' }],
    name: 'updateLiquidityLocker',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ internalType: 'address', name: 'newVault', type: 'address' }],
    name: 'updateVault',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [],
    name: 'vault',
    outputs: [{ internalType: 'contract IClankerVault', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'weth',
    outputs: [{ internalType: 'address', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const; -- src/abis/Clanker_V3_1.ts -- src/constants.ts -- src/index.ts -- src/types.ts -- and the deployment script: import { createPublicClient, createWalletClient, http, type PublicClient } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { base } from 'viem/chains';
import { privateKeyToAccount } from "viem/accounts";
import { Clanker } from '../src';
import * as dotenv from "dotenv";

// Hardcoded values from llm.txt

const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' as const;
const WETH_ADDRESS = '0x4200000000000000000000000000000000000006' as const;

// Load environment variables
dotenv.config();

const PRIVATE_KEY = process.env.PRIVATE_KEY as `0x${string}`;
const FACTORY_ADDRESS = process.env.FACTORY_ADDRESS as `0x${string}`;
const RPC_URL = process.env.RPC_URL;

if (!PRIVATE_KEY || !FACTORY_ADDRESS) {
  throw new Error("Missing required environment variables");
}

const account = privateKeyToAccount(PRIVATE_KEY);
async function main() {
  console.log('Starting token deployment with custom configuration...');
  console.log('Deploying token with USDC as quote token...');

  // Initialize the wallet and public client

  const publicClient = createPublicClient({
    chain: base,
    transport: http(RPC_URL),
  }) as PublicClient;
  const walletClient = createWalletClient({
    account,
    chain: base,
    transport: http(RPC_URL),
  });

  // Initialize Clanker SDK
  const clanker = new Clanker({
    wallet: walletClient,
    publicClient,
    factoryAddress: FACTORY_ADDRESS,
  });

  // Deploy token with custom configuration
  const tokenAddress = await clanker.deployToken({
    name: "Test Token997",
    symbol: "TEST997",
    metadata: {
      description: "Test token deployment",
      socialMediaUrls: [],
      auditUrls: [],
    },
    context: {
      interface: "Clanker SDK Test",
      platform: "Clanker",
      messageId: "Test Deploy",
      id: "TEST-1",
    },
    pool: {
      quoteToken: USDC_ADDRESS,
      initialMarketCap: '100', // Raw value, SDK will handle decimals
    },
    vault: {
      percentage: 10,
      durationInDays: 30,
    },
    devBuy: {
      ethAmount: '0.00001', // 0.00001 ETH dev buy
      maxSlippage: 5, // 5% max slippage
    },
  });

  console.log('Deployment successful!');
  console.log('Token address:', tokenAddress);
}

main().catch(console.error);  -- in examples/deploy-full-sdk.ts 

4. we will leverage providers/clients/etc that should actually already exist in minikit / onchainkit and pass them in to the clanker-sdk if possible, remember these are abstractions of wagmi viem (onchain kit / minikit / transact etc so we should be able to pass those in as props or whatever into the clanker-sdk )

5. from transaction docs: transactioncomponent.tsx: import { useCallback } from 'react';
import { Avatar, Name } from '@coinbase/onchainkit/identity';
import { 
  Transaction, 
  TransactionButton,
  TransactionSponsor,
  TransactionStatus,
  TransactionStatusAction,
  TransactionStatusLabel,
} from '@coinbase/onchainkit/transaction'; 
import type { LifecycleStatus } from '@coinbase/onchainkit/transaction';
import { Wallet, ConnectWallet } from '@coinbase/onchainkit/wallet';
import { useAccount } from 'wagmi';
import { calls } from '@/calls'; 
 
 
export default function TransactionComponents() {
  const { address } = useAccount();
 
  const handleOnStatus = useCallback((status: LifecycleStatus) => {
    console.log('LifecycleStatus', status);
  }, []);
 
  return address ? (
    <Transaction
      chainId={BASE_SEPOLIA_CHAIN_ID} 
      calls={calls} 
      onStatus={handleOnStatus} 
    >
      <TransactionButton />
      <TransactionSponsor />
      <TransactionStatus>
        <TransactionStatusLabel />
        <TransactionStatusAction />
      </TransactionStatus>
    </Transaction> 
  ) : (
    <Wallet>
      <ConnectWallet>
        <Avatar className='h-6 w-6' />
        <Name />
      </ConnectWallet>
    </Wallet>
  );
}; -- and calls.ts which is an example of calling a contract: const clickContractAddress = '0x67c97D1FB8184F038592b2109F854dfb09C77C75';
const clickContractAbi = [
  {
    type: 'function',
    name: 'click',
    inputs: [],
    outputs: [],
    stateMutability: 'nonpayable',
  },
] as const;
 
export const calls = [
  {
    address: clickContractAddress,
    abi: clickContractAbi,
    functionName: 'click',
    args: [],
  }
]; 

6. remember we are: using clanker-sdk (but rather than initializing new clients via wagmi we are passing in existing clients) to calculate information based on deployment parameters input, and then pass them to the transaction component as a call 


7. this is the code state that is working, however the transaction goes through (onchain ive confirmed a few through basescan) and we are left in a circle / building transaction state: 
'use client';

import { useCallback, useState } from 'react';
import { useAccount, usePublicClient, useWalletClient, useChainId } from 'wagmi';
import { base } from 'viem/chains';
import {
  Transaction,
  TransactionButton,
  TransactionToast,
  TransactionToastAction,
  TransactionToastIcon,
  TransactionToastLabel,
  TransactionError,
  TransactionResponse,
  TransactionStatusAction,
  TransactionStatusLabel,
  TransactionStatus,
} from "@coinbase/onchainkit/transaction";
import { useNotification } from "@coinbase/onchainkit/minikit";
import { Clanker } from 'clanker-sdk';

const DEFAULT_IMAGE = 'ipfs://bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi';
const CLANKER_FACTORY = '0x2A787b2362021cC3eEa3C24C4748a6cD5B687382' as `0x${string}`;
const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' as const;
const WETH_ADDRESS = '0x4200000000000000000000000000000000000006' as const;

type QuoteTokenOption = 'USDC' | 'WETH' | 'CUSTOM';

export default function TokenDeployForm() {
  const [formData, setFormData] = useState({
    name: 'Test Token',
    symbol: 'TEST',
    image: DEFAULT_IMAGE,
    quoteTokenOption: 'WETH' as QuoteTokenOption,
    customQuoteToken: '',
    initialMarketCap: '100',
    devBuyAmount: '0.00001',
    vaultPercentage: 0,
    vaultDurationDays: 0,
  });

  const { address } = useAccount();
  const { data: walletClient } = useWalletClient();
  const publicClient = usePublicClient();
  const chainId = useChainId();
  const sendNotification = useNotification();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Prepare the deployment configuration
  const getDeploymentConfig = useCallback(() => {
    if (!address || !walletClient || !publicClient) {
      return null;
    }

    // Move getQuoteTokenAddress inside the callback
    const getQuoteTokenAddress = (): `0x${string}` => {
      switch (formData.quoteTokenOption) {
        case 'USDC':
          return USDC_ADDRESS as `0x${string}`;
        case 'WETH':
          return WETH_ADDRESS as `0x${string}`;
        case 'CUSTOM':
          return formData.customQuoteToken as `0x${string}`;
        default:
          return USDC_ADDRESS as `0x${string}`;
      }
    };

    const config = {
      name: formData.name,
      symbol: formData.symbol,
      image: formData.image,
      pool: {
        quoteToken: getQuoteTokenAddress(),
        initialMarketCap: formData.initialMarketCap,
      },
      vault: {
        percentage: Number(formData.vaultPercentage),
        durationInDays: Number(formData.vaultDurationDays),
      },
      devBuy: {
        ethAmount: formData.devBuyAmount
      },
    };

    const clanker = new Clanker({
      wallet: walletClient,
      publicClient,
      factoryAddress: CLANKER_FACTORY,
    });

    return { config, clanker };
  }, [address, walletClient, publicClient, formData]);

  const handleSuccess = useCallback(async (response: TransactionResponse) => {
    const transactionHash = response.transactionReceipts[0].transactionHash;
    console.log(`Token deployment successful: ${transactionHash}`);
    
    await sendNotification({
      title: "Token Deployed!",
      body: `Your token has been deployed successfully. TX: ${transactionHash}`,
    });
  }, [sendNotification]);

  // Get the transaction calls
  const calls = useCallback(async () => {
    const deployment = getDeploymentConfig();
    if (!deployment) return [];

    try {
      const txData = await deployment.clanker.deployToken(deployment.config);
      return [{
        to: CLANKER_FACTORY,
        data: txData,
        value: BigInt(formData.devBuyAmount)
      }];
    } catch (error) {
      console.error('Error preparing deployment:', error);
      return [];
    }
  }, [getDeploymentConfig, formData.devBuyAmount]);

  return (
    <div className="max-w-2xl mx-auto p-6 bg-[var(--app-card-bg)] rounded-lg shadow-lg border border-[var(--app-card-border)]">
      <h2 className="text-2xl font-bold mb-6 text-[var(--app-foreground)]">Deploy Token</h2>
      
      <div className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Name</label>
            <input
              type="text"
              name="name"
              value={formData.name}
              onChange={handleInputChange}
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Symbol</label>
            <input
              type="text"
              name="symbol"
              value={formData.symbol}
              onChange={handleInputChange}
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Token Image URL</label>
            <p className="text-xs text-[var(--app-foreground-muted)] mb-2">Format: ipfs://[PUT CID HERE]</p>
            <input
              type="text"
              name="image"
              value={formData.image}
              onChange={handleInputChange}
              placeholder="ipfs://bafybeig..."
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
              pattern="^ipfs:\/\/[a-zA-Z0-9]+"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Quote Token</label>
            <select
              name="quoteTokenOption"
              value={formData.quoteTokenOption}
              onChange={handleInputChange}
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
            >
              <option value="USDC">USDC</option>
              <option value="WETH">WETH</option>
              <option value="CUSTOM">Custom Token</option>
            </select>
            {formData.quoteTokenOption === 'CUSTOM' && (
              <input
                type="text"
                name="customQuoteToken"
                value={formData.customQuoteToken}
                onChange={handleInputChange}
                placeholder="Enter token address (0x...)"
                className="mt-2 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
                pattern="^0x[a-fA-F0-9]{40}$"
                required
              />
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Initial Market Cap (**in Quote Token**)</label>
            <input
              type="text"
              name="initialMarketCap"
              value={formData.initialMarketCap}
              onChange={handleInputChange}
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Dev Buy Amount (ETH)</label>
            <input
              type="text"
              name="devBuyAmount"
              value={formData.devBuyAmount}
              onChange={handleInputChange}
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Vault Percentage</label>
            <input
              type="number"
              name="vaultPercentage"
              value={formData.vaultPercentage}
              onChange={handleInputChange}
              min="0"
              max="100"
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-[var(--app-foreground-muted)]">Vault Duration (days)</label>
            <input
              type="number"
              name="vaultDurationDays"
              value={formData.vaultDurationDays}
              onChange={handleInputChange}
              min="1"
              className="mt-1 block w-full px-3 py-2 bg-[var(--app-card-bg)] border border-[var(--app-card-border)] rounded-lg text-[var(--app-foreground)] placeholder-[var(--app-foreground-muted)] focus:outline-none focus:ring-1 focus:ring-[var(--app-accent)]"
              required
            />
          </div>
        </div>

        <div className="flex flex-col items-center mt-6">
          {address ? (
            chainId === base.id ? (
              <Transaction
                chainId={base.id}
                calls={calls}
                onSuccess={handleSuccess}
                onError={(error: TransactionError) => {
                  console.error("Token deployment failed:", error);
                }}
              >
                <TransactionButton />
                <TransactionStatus>
                  <TransactionStatusAction />
                  <TransactionStatusLabel />
                </TransactionStatus>
                <TransactionToast>
                  <TransactionToastIcon />
                  <TransactionToastLabel />
                  <TransactionToastAction />
                </TransactionToast>
              </Transaction>
            ) : (
              <p className="text-yellow-400 text-sm text-center">
                Please switch to Base mainnet
              </p>
            )
          ) : (
            <p className="text-yellow-400 text-sm text-center mt-2">
              Connect your wallet to deploy a token
            </p>
          )}
        </div>
      </div>
    </div>
  );
} 